# The-Way-To-Go
![](/assets/mascot.jpeg)

Go, whose authentic name is [Go](https://go.dev/doc/faq#go_or_golang) (though the moniker "Golang" is conveniently used), came into existence due to exasperation with prevailing languages and frameworks utilized within Google. Without delving into the exhaustive introductory details, let's swiftly move past those preliminaries. If you're perusing this, chances are you possess a reasonable understanding of Go; however, if that's not the case, I recommend investing around 20 minutes in online research before returning here, as this article holds substantial importance for you. Moreover, I'll dispense with formalities and dive straight into the heart of the matter, opting for a conversational tone. Your continued readership is greatly appreciated.

## First Recommendation: "Learning Go"
![](/assets/learning_go.jpg)

Authored by Joe Bodner, if you're delving into Go for the very first time, "Learning Go" should be your initial port of call. Allow me to emphasize this with conviction. Choosing this book will be a decision you won't rue; I wholeheartedly endorse it—indeed, I can't stress it enough. While an alternative option often referred to as the "Go Bible" exists (depicted by the smaller image below), it's important to note that not only is that book dated, but, in my perspective, it's better suited for individuals arriving with a wealth of programming experience, particularly with languages such as C, C++, or Java.

In my personal journey, transitioning from languages like Python and JavaScript, I fervently advocate for "Learning Go" over the aforementioned alternative. Allow me to refrain from further hammering the point, but to alleviate any wavering doubts, I reiterate: "Learning Go" is undeniably the path to tread. Not only does it present the language in a lucid manner, but it also imparts the idiomatic approach to coding—precisely how to proficiently craft code akin to an industry expert. Spare yourself the ordeal of, like myself, sifting through various literary sources. Trust me, begin with this book, it is "the-way-to-Go".

![](/assets/go_bible.jpg)

## Second Recommendation: "Let Go"
![](/assets/let_go.jpg)

Go shines unmistakably as the go-to choice for constructing backend systems—ranging from elementary webservers to expansive, intricate microservices (particularly the latter). Hence, it's judicious to envision yourself as a backend engineer when venturing into the realm of Go. Assuming you've delved into at least 8 chapters of "Learning Go," the next logical step is "Let's Go," the paramount guide to initiating your journey into building Go-based webservers.

Allow me to emphasize the sheer excellence of this book. Not only does it facilitate the creation of backend systems using Go, but its methodologies are profoundly applicable within the industry landscape. The resonance between its teachings and industry standards is nothing short of remarkable.The book stayed off frameworks and kept with standard libraries and a few external libraries just when needed, as recommednded by most Gophers.

While other options exist, I implore you with the utmost sincerity, select "Let's Go." I assure you, the decision will be void of regrets. Authored by Alex Edwards.

## Third Recommendation: "Powerful Command-Line Applications In Go"
![](/assets/cli.jpg)

Authored by Ricardo Gerardi, the second most prevalent utilization of Go lies in crafting command-line applications and various forms of tooling. This book adeptly delivers simplicity, conciseness, and efficiency adhering to industry standards. Notably, the book goes above and beyond in its approach to acquainting readers with the language. Thus, comprehending the content poses no significant challenge.

However, what I find particularly captivating and immensely valuable within its pages is the extensive integration of testing. Trust me, testing holds paramount significance in the realm of Go, underscoring its status as a professional-grade language.

While alternative learning resources for Go-based command-line interfaces exist, I wholeheartedly vouch for this book based on my extensive readings. If you're embarking on your Go journey and seek a comprehensive exploration of command-line intricacies, all conveniently bundled within a single source, this book stands unparalleled. Although I might entertain the notion of interchanging its ranking with "Let's Go," I recommend reserving this book as the third resource to explore.

## Fourth Recommendation: "Let Go Further"
![](/assets/let_go_further.jpg)

Ricardo Gerardi's book stands as an all-encompassing guide for initiating a promising career in Go's command-line interface domain. With its comprehensive coverage, this book has the potential to be the sole reference, rendering other resources redundant—unless your requirements extend to specific domain-level aspects of your CLI application. For those, you might need supplementary materials. However, the core of building CLIs is thoroughly addressed by Gerardi's work.

However, transitioning to our second recommendation—focused on the realm of crafting Go-based webservers—embodies a more nuanced journey. The same author, extending his expertise, presents "Let's Go Further," a work designed to propel your understanding into the realm of intricate, expansive, and scalable applications. This offering delves into the realm of advanced topics, encompassing caching strategies, meticulous metrics implementation, sophisticated routing mechanisms, bolstered security protocols, and even the complexities of rate limiting.

Let me emphasize: this book isn't a casual read. It's not something you'll breeze through effortlessly. But in terms of usefulness, it's an unparalleled gem. When you delve into its pages, you'll likely be enticed to immerse yourself in its content, emerging with a rock-solid confidence that makes applying for backend engineering roles a tantalizing prospect. That's the kind of transformative impact this book has to offer, particularly if you're aiming to harness the backend prowess of Go.


## Fifth Recommendation: "Concurrency In Go"
![](/assets/concurrency.jpg)

Concurrency stands out as one of Go's flagship features, often touted as its prime selling point. For those truly intent on unraveling the intricacies that underlie this facet, the book I'm about to introduce is indispensable. It takes on the task of proficiently teaching fellow Go developers about the subtleties of Go's concurrency mechanism.

Allow me to clarify further: suppose you've traversed the content of at least three of the previously mentioned books, supplemented by numerous hands-on projects, an exploration of other developers' code, the consumption of YouTube tutorials, and the perusal of miscellaneous Go-related articles. In that case, you're likely to acquire a functional understanding of Go's concurrency through practical experience. However, if your aspirations involve more than mere practical application—such as articulating concepts in seminars or contributing to the creation of libraries—this book assumes paramount importance. It serves as the compass that guides you through the maze of Go's concurrency, eliminating doubts and illuminating best practices, with particular emphasis on the often-elusive `select` keyword.

If your schedule proves tight, consider dedicating time to one or two chapters situated towards the book's conclusion. You're bound to unearth invaluable insights. Even I, myself, confess to not having fully exhausted its contents; it's a testament to the wealth of knowledge encapsulated within.
## Sixth Recommendation: "Go Design Patterns
![](/assets/go_design_packt.jpg)
 
In the realm of programming, a profound understanding of design patterns holds significant weight. This understanding becomes even more pivotal when you're actively engaged in a Go-centric role—whether that involves professional work, contributing to open-source projects, or constructing extensive applications. Purposeful design isn't just a suggestion; it's a necessity.

Granted, many design patterns are applicable across multiple programming languages, transcending the boundaries of specificity. Hence, if you're well-versed in these concepts, feel free to bypass this book. However, if you're relatively new to the world of design patterns or eager to grasp their implementation within the context of Go, this book comes highly recommended.

To clarify, I don't necessarily read this book from cover to cover. Instead, I refer to it when the need arises. This approach aligns with my recommendation for you as well. When it comes to design patterns, it's a valuable reference that offers a clear and proficient exploration of the subject matter. While I might not be actively reading it at this moment, its presence as a resource to address specific queries or challenges remains invaluable.

# CONCLUSION
Let's engage in a candid conversation here. It's evident that I've immersed myself in extensive reading and possess a genuine passion for learning. While this inclination is indeed commendable, I'd like to share a crucial insight: as a developer, it's pivotal not to let the pursuit of knowledge overshadow the practical act of problem-solving and project completion.

My sentiment resonates with a universal truth—getting absorbed in an insatiable quest for knowledge, without translating it into actual projects, can lead to regrets. This behavior often results in accumulating an abundance of theoretical knowledge that doesn't get a chance to manifest itself practically. The cycle can spiral to a point where there's an overwhelming number of ideas and concepts to explore, yet little has been implemented.

The crux of the matter is this: the real essence of programming lies in two intertwined activities—problem-solving (the conceptualization of solutions) and coding (the translation of these solutions into executable code). While learning is undoubtedly a critical foundation, its true value comes to fruition when you actively apply it. Coding isn't just about syntax and rules; it's about practical execution, creating tangible solutions, and refining your skills through hands-on experience.

So, heed this advice: don't delay coding until you've consumed an entire book or chapter. Engage with the material as you progress. Embrace playful coding, even if it's merely a twist on the examples you encounter. The muscle of programming and coding strengthens when you immediately put newly acquired knowledge to use.

Furthermore, let's address the pace of consumption. It's a common pitfall to devour numerous books in a short span, say, three to six months. However, I implore you to tread cautiously. Instead of rushing through volumes of reading material, invest significant time in actually constructing with Go. Prioritize building projects that demonstrate your understanding and proficiency. In this endeavor, quality reigns supreme over quantity.

Bear in mind that the rabbit hole of continuous book consumption can indeed be a trap. The allure of acquiring knowledge can overshadow the satisfaction of implementing it. Strive for a balanced approach—one that marries learning with practical application. The ultimate goal is not to accumulate knowledge for its own sake but to utilize it in generating meaningful solutions.

Your wisdom in recognizing this pattern is commendable, and your advice holds weight: aspiring developers, take heed. Invest time in both learning and doing, but never forget that the true essence of programming is crafting solutions through coding. It's the fusion of knowledge and action that paves the way for genuine growth and expertise.

## Feedback

Firstly, thank you for getting this far, if you ever want to contact me, reach me via this [email](giwaoluwatobi@gmail.com). I have other books I can recommend to get better or to try more advanced stuff, maybe a next time if you folks still want to hear it. And yes, that first image was produced by [DALL-E2](https://openai.com/dall-e-2), probably the first if it kind (I guess that makes me the author sort of). Bye.
